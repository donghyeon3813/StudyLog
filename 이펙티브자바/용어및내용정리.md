
#### Builder Pattern
복잡한 객체 생성과정과 표현 방법을 분리하여 다양한 구성의 인스턴스를 만드는 생성 패턴 
~~~ java
// 생성자 방식
Student student1 = new Student(2024021400, "둘리", "010-9999-9999");

// 빌더 방식
Student student2 = new StudentBuilder()
            .id(2024021400)
            .name("둘리")
            .phoneNumber("010-9999-9999")
            .build();
~~~~
#### 직렬화 
객체의 상태를 바이트 스트림( 파일, 데이터베이스 ,메모리 )으로 변환하여 저장하거나 다른 시스템으로 전송 
#### 역직렬화 
바이트로 변환된 데이터를 다시 객체로 변환 

#### Fluent api = Method chaing 
메서드가 객체를 반환하여 연쇄적으로 메서드를 호출하는 기법 
ex) Builder Pattern

#### 계층적으로 설계된 클래스 

#### 가변인수 (varargs) 
매개변수로 들어오는 값의 갯수와 관계 없이 동적으로 인수를 받을 수 있게 해주는 문법
ex) System.out.printf() 
#### Reflection 
객체를 통해 클래스의 정보를 분석하여 런타임에 클래스의 동작을 조작하는 기법 
#### 공변 반환 타이핑 ( Covariant return typing ) 
하위 클래스의 메서드가 상위 클래스의 메서드가 정의한 반환 타입이 아닌, 그 하위 타입을 반환하는 기능

#### 싱글턴 (Singleton) 
인스턴스를 오직 하나만 생성할 수 있는 클래스

#### 자바빈즈 패턴 (JavaBeans Pattern) 
매개 변수가 없는 생성자로 객체를 만든 후 , setter method를 호출해 원하는 매개변수 값을 설정하는 방식 <br>
단점 ) 객체 하나를 만드려면 여러개의 메서드 호출 , 객체가 완전히 생성되기 전까지는 일관성이 무너진 상태 , 클래스를 불변으로 만들 수 없음 

#### Factory
호출할 때마다 특정 타입의 인스턴스를 반복해서 만들어주는 객체

#### item 44 표준 함수형 인터페이스를 사용하라
> 자바에서 제공하는 표준 함수형 인터페이스를 사용해 코드의 일관성과 가독성을 높이고자 하는 방식. 표준 인터페이스를 사용하면, 코드의 재사용성이 향상되고, 다양한 API와 호환성 향상.
~~~ java
Function<T, R>: 입력을 받아 변환 -> 결과 반환 (T → R)
Consumer<T>: 입력을 받아 처리 -> 결과 반환 안함 (T → void)
Supplier<T>: 입력 없이 결과 반환 (void → T)
Predicate<T>: 입력을 받아 -> boolean 값을 반환 (T → boolean)
BiFunction<T, U, R>: 두 개의 입력 받아 변환 -> 결과 반환 (T, U → R)
~~~ 

#### item 45 스트림은 주의해서 사용하라 

> 스트림의 장점 / 단점 
- 장점 : 스트림 API는 데이터 처리 파이프라인을 간결하고 읽기 쉽게 만들어줌
- 단점 : 복잡한 스트림은 코드의 가독성 저하, 디버깅 및 유지보수 어려움

> 스트림 vs 반복문 
- 간단한 데이터 처리나 불변 데이터 처리시에는 스트림이 더 적합할 수 있음 
- 상태를 추적하거나 복잡한 비즈니스 로직 처리시에는 반복문이 더 적합할수 있음 
- 만약 확신하기 어렵다면, 둘 다 해보고 성능 비교 후 적용

#### item 46 스트림에서는 부작용 없는 함수를 사용하라

- 스트림 API는 함수형 프로그래밍 기반 <br> 
- 순수함수를 사용해 부작용을 최소화하는 것 ( 외부 상태를 변경하지 않으며, 입력이 같으면 항상 동일한 출력을 반환 ) 

> foreach 
- 주로 결과를 출력하거나 로그를 기록하는데 적합, 결과를 수집하거나 외부 상태를 수정하는데는 부적합. 결과를 수집할때는 collect를 사용하는것이 좋음
> toMap
- 스트림의 결과를 맵으로 수집할 때 사용. 중복된 키가 있을 경우 IllegalStateException 예외가 발생할 수 있음.
> groupingBy
- 스트림의 결과를 기준에 따라 그룹화하여 맵 형태로 수집
> joining 
- CharSequence 인스턴스의 스트림에만 적용 가능
- 지정된 구분자를 사용하여 하나의 문자열로 결합

#### item 47 반환 타입으로는 스트림보다 컬렉션이 낫다
#### item 48 스트림 병렬화는 주의해서 적용하라
- 원소 시퀀스를 반환하는 api 메서드 작성시 스트림, 반복으로 처리하길 바라는 사용자 양쪽을 만족시키려 하자
- 반환 전부터 이미 원소들을 컬렉션에 담아 관리하고 있거나 원소 개수가 적다면 표준 컬렉션에 담아 반환. 그렇지 않으면 전용 컬렉션 구현
- 컬렉션 반환이 불가능하면 스트림 또는 Iterable 중 선택해서 반환

> 스트림 vs 컬렉션
1. 스트림
   - 데이터를 처리하는 API
   - 일회성 , 한번 사용 후 재사용 불가
   - 지연 평가
   - 내부 반복
   - parallerStream()을 통해 간단히 병렬 처리 가능
   - 필터링, 매핑, 집계 등 데이터 처리 중심 함수 제공
   - 순차 접근과 병렬 접근 가능

 2. 컬렉션
   - 데이터를 저장하고 관리하는 자료구조
   - 여러번 데이터를 반복하며 재사용 가능
   - 즉시 평가
   - 외부반복
   - 순차처리
   - 데이터 추가, 삭제 , 사이즈 확인, 포함 여부 확인
   - 순차 접근

```` java
// 데이터 예시
List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");

// 컬렉션을 사용한 연산
List<String> filteredNames = new ArrayList<>();
for (String name : names) {
    if (name.length() > 3) { // 필터링 조건
        filteredNames.add(name.toUpperCase()); // 변환
    }
}
System.out.println(filteredNames); // 출력: [ALICE, CHARLIE, DAVID]

// 스트림을 사용한 연산
List<String> streamResult = names.stream()
    .filter(name -> name.length() > 3) // 필터링 조건
    .map(String::toUpperCase)          // 변환
    .collect(Collectors.toList());     // 결과 수집
System.out.println(streamResult);      // 출력: [ALICE, CHARLIE, DAVID]
````

> 내부반복 vs 외부반복
1. 외부반복
- 개발자가 직접 반복문을 사용하여 컬렉션의 요소를 순회하는 방법.
- 순서와 제어는 개발자가 직접 담당
  
2. 내부반복
- 자바의 Stream Api, 컬렉션 foreach 처럼 반복의 제어권을 라이브러리에 맡기고, 처리할 작업만 정의 하는 방법.
- 개발자는 처리할 작업만 정의

> 스트림의 병렬처리
- 스트림에서의 병렬처리는 리스트나 컬렉션의 데이터를 여러 작업으로 나누어 여러 스레드에서 동시에 처리한다는것
- 리스트를 여러 개의 작은 작업 단위로 나누고, 각각의 단위를 병렬로 처리. 예를 들어, 10개의 요소가 있는 리스트가 있다면, 병렬 스트림은 이를 2개의 하위 스트림으로 나누어 5개씩 각각 다른 스레드에서 처리. 이때 전체 데이터가 나눠져 동시에 처리

1. 데이터 분할(Splitting) 
- 스트림의 데이터를 여러 하위 스트림으로 분할. 분할 과정은 자바의 Spliterator 인터페이스가 담당
2. 병렬 처리(Parallel Processing)
- 각 하위 스트림을 별도의 스레드에서 동시에 처리합니다. 내부적으로 자바의 Fork/Join 프레임워크를 사용하여 여러 스레드가 데이터를 병렬로 처리.
3. 결과 병합(Merging Results)
- 병렬로 처리된 각 하위 스트림의 결과를 결합하여 최종 결과를 도출

> 병렬 스트림 vs 멀티스레딩
- 멀티 스레드 : 여러 스레드가 동일한 작업을 독립적으로 수행하는 방식
- 병렬 스트림 : 여러 스레드를 사용하지만, 특정 데이터를 여러번 호출하는것이 아니라 데이터를 나누어 병렬로 처리

#### item 49 매개변수가 유효한지 검사하라 
> 실패 원자성 (Failure Atomicity) , 298p
- 메서드가 예외를 던졌을때, 그 메서드가 객체의 상태를 변경하지않거나, 부분적으로만 변경하는 것을 방지
- 메서드 호출이 실패해도 객체는 예외가 발생하기 전의 상태로 유지되어야한다
> 실패 원자성을 보장하기 위해서는?
- 메서드 내부의 상태를 변경하는 코드가 실행되기 전에 유효성 검사를 먼저 수행, 상태 변경이 실패할 경우 이를 롤백하여 객체가 일관된 상태를 유지할 수 있도록 설계 

> 클래스 불변식 , 300p
- 클래스의 인스턴스가 생성된 이후, 그 인스턴스의 메서드가 호출된 후에도 항상 참이어야하는 조건이나 속성
- 객체의 상태는 특정 조건을 항상 만족해야함을 보장하는 규칙

> 예외번역 (Exception Translate) , 301p
- 하위 계층에서 발생한 예외를 상위 계층에서 보다 의미있는 예외로 변환하는 기법
- 장점 : 시스템의 모듈성을 높이고, 예외 처리의 일관성을 유지

> 범용적인 설계 , 301p
- 특정한 상황이나 조건에 제한되지 않고, 다양한 상황에 유연하게 대응할 수 있는 설계
- 재사용성을 높이고, 유지보수를 쉽게 만들어줌

#### item 50 적시에 방어적 복사본을 만들라

> 방어적 복사 (Defensive Copy)
- 객체의 내부 상태를 보호하기 위해, 외부에서 전달된 가변 객체를 그대로 사용하거나 외부로 반환하지 않고, 그 객체의 복사본을 만들어 사용하는 기법
- 































